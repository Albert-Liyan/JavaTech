
#### 1 微服务与云原生架构
- 单体架构
- 面向服务架构
- 微服务架构
- 云原生架构

1 单体架构
所有的业务逻辑和控制逻辑放在一起，一个程序里包括所有相关的功能。例如：一个ERP系统中包括商品模块、订单模块、销售模块、库存模块、报表统计等
听起来不厉害，但单体架构基本解决了所有简单的问题。开发时所有业务代码都在一起，测试不需要联调，发布维护简单。

| 优势      | 劣势 |
| :---        |    :----:   |
| 自包含单元<br> 低延时<br> 易测试，易维护<br> 整体架构简单     | 开发周期长<br> 吞吐量低<br> 紧耦合低内聚<br> 隔离性差<br> 故障容忍度差<br> 持续集成和部署困难<br> 扩展性差       |

2 面向服务架构（SOA）
随着业务系统越来越复杂，对单体架构进行`垂直拆分`演变，比如ERP系统，按照功能将用户、商品、交易等不同部分拆分成独立服务（数据库也需要拆分）。虽然看起来比单体架构厉害了，但还存在对应问题，比如每个拆分之后的服务还是单体服务，公共模块没有拆分。（Marketplace）

总结面向服务架构的优劣势：
| 优势      | 劣势 |
| :---        |    :----:   |
| 服务解耦<br> 服务隔离性好<br>可持续集成和部署<br> 易测试和运维<br>集中式的服务治理<br>架构不复杂 | 厚重和复杂的ESB<br> 业务逻辑侵入ESB<br> ESB故障影响面太大<br> 扩展性一般<br> 开发周期适中<br> 适中响应时间，低吞吐量       |

3 微服务架构
不仅对垂直方向拆分，同时按照水平方向进一步拆分，即微服务架构模式。微服务架构模式下，大项目被拆分成一个个小的，且可独立部署的微服务，每个微服务都有自己的数据库。

比如上面ERP系统，商品、用户、订单、库存等不同部分都成为独立的微服务，每一个服务之间都可以进行直接的通信。（CloudMNet，拆分不够细）

微服务是在移除ESB之后，更为轻量、更为松耦合的服务，把ESB的控制逻辑以SDK的方式注入到每个微服务中进行服务控制和治理，架构更为`分布式`。

由于微服务的要素之一就是“微”，所以大多数微服务都是基于容器调度管理（Docerk、k8s等字样）

| 优势      | 劣势 |
| :---        |    :----:   |
| 开发周期短<br> 松耦合，高内聚<br> 高吞吐量<br> 快速持续部署<br> 低故障影响，高可用<br> 扩展性很好<br> 开放技术栈 | 测试和运维难度大<br> 服务治理变困难<br> 响应时间变长<br> 架构非常复杂<br> 技术门槛高  |

SOA是什么
Service Oriented Architecture，服务导向架构， SOA描述一种IT基础设施的应用集成模型。其中软构建集是以一种定义清晰的层次化结构来耦合。

ESB是什么
企业服务总线（Enterprise Service Bus，ESB）从SOA发展而来，一个ESB是一个预先组装的SOA实现，包含实现SOA分层目标所需的基础功能组件。

4 云原生架构
随着微服务架构能解决的问题越来越广泛，出现了对应的云原生架构。云原生不是新的技术，基于`微服务架构思想`、以`容器技术`为载体的一种产品研发运营全新模式。

云原生，即是基于云计算特性设计的应用服务。基于云计算特性设计的云原生应用相比传统单体应用在安全性、扩展性、快速迭代、运维方面有巨大领先优势。云原生不是某一种技术，是一种`架构理念`。

云原生依赖容器技术，但容器并非云时代的核心技术，`容器编排`(Kubernetes) 才是。


#### 2 云原生架构技术栈(Todo 技术栈必须了解基本原理、用法)
云原生核心技术是K8s和Docker，还包括以下
- 容器和镜像 `Docker`
- 持续集成 GitHub Action, Jenkins, Tekton
- 镜像仓库 Harbor
- 应用定义 Helm，Kustomize
- 持续部署 FluxCD, ArgoCD
- 密钥管理 Vault
- 容器编排 `K8s`
- 网关 Ingress-Nginx
- 监控 Grafana
- 告警 Prometheus
- 应用开发 Nocalhost

云原生技术终极目标：微服务的开发、交付和运维

##### 微服务
在微服务和云原生架构下，微服务构建成容器镜像，镜像部署到k8s，然后以Pod的工作负载类型运行。
微服务 -> 容器镜像 -> Pod(K8s)
需要用到以下云原生技术：
1 构建镜像: Docker
2 持续集成: GitHub Action, Jenkins, GiaLab CI等
3 镜像仓库：Harbor

容器镜像部署到K8s过程，需要用到以下技术：
1 应用定义：Helm、Kustomize
2 持续部署：FluxCD、ArgoCD
3 密钥管理: Vault
4 容器编排: K8s

参考 微服务和云原生架构的关系
https://www.zhihu.com/question/361320719

##### 为什么用云原生架构？
- 自动恢复
  应用系统挂掉后（代码没写好OOM，服务器资源不足，死锁、磁盘、网络等问题），不需人工接入，在最短时间内能恢复，保证系统健壮性。
- 服务安全
  服务隔离+资源隔离（Pod）
- 弹性扩展
  任意扩展、伸缩，资源使用上提供按量付费
- 快速发布
  Rolling Update 滚动升级

#### 3 云原生架构的核心技术（微服务、DevOps、容器云、Service Mesh、Serverless、声明式API）

名词：
- IaaS
- SaaS
- PaaS
- BaaS 
后端即服务，应用架构由大量第三方云服务器和API组成的，使应用中关于服务器的逻辑和状态都由服务提供方来管理的。`只需要调用服务提供方的API即可完成相应的功能`，比如常见身份验证、云端数据、文件存储、消息推送、应用数据分析等。
- FaaS
函数即服务，一种实现无服务器计算的防范，服务商提供一个平台，允许客户开发、运行和管理应用程序功能，而无需构建和维护通常与开发和启动应用程序相关的基础架构的复杂性。`通常在构建微服务应用程序时使用`。

- XaaS
- Kubernetes
简称k8s，Google开源的一个容器编排引擎，用于管理云平台中多个主机上容器化的应用。部署容器化的应用简单、高效，Kubernetes提供了应用部署，规划，更新，维护的一种机制。

##### 微服务
核心是传统大单体应用拆分更小的组件或模块，即微服务。
`纵向拆分`，从底层基础设施到数据库、应用中间件到软件应用部署包都能做到完全独立的一套。单独的从需求设计、开发、打包、部署，全都能独立，实现各个微服务之间的`松耦合`, 同时各个微服务之间能通过轻量http rest接口协同。总结微服务核心要点：大的单体拆小、拆小的微服务能协同（轻量http rest接口）

![](./picture/微服务架构_运行_设计.JPG)
![](./picture/微服务架构.png)

##### DevOps
开发运维一体化，核心要点`持续集成和持续交付`。
软件生命周期过程中：需求设计、开发、构建部署、测试环境、生产环境整个过程都能实现全部自动化。同时又进一步集成敏捷开发、自动化测试相关的最佳实践。

NetMonitor、CloudMNet做的事情。

##### Service Mesh
Service Mesh，服务网格： 一个去中心化的服务治理框架。

原来对服务、Api接口治理和管控，一般会用API网关把api接口注册和接入到api网关，API网关是一个中心化的架构，所有流量请求都可以通过API网关，API网关可以很容易对流量拦截，对拦截以后的流量进行安全、日志、限流、熔断、链路监控等管控治理。

在去中心化的架构，对于流量的拦截从API网关下沉到各个微服务，例如`Istio`微服务治理框架，会在服务端下发一个`sidecar`（边车）代理，通过代理实现流量拦截和管控。去中心化的治理仍然有一个控制中心，控制中心仍然是中心化，但`控制流和接口数据访问的消息流实现了分离，控制流只管服务注册与发现，实际接口调用、服务访问不通过控制中，一句话即使控制中心宕机也不会影响都接口服务调用`。


###### Serverless
无服务架构，云原生发展到后期以后，云原生的核心就是`实现从资源到服务不断向上抽象`，开发越来越不会接触到底层的IT基础设施，只会关注各种技术能力，这些技术能力在Serverless架构叫BaaS。

Serverless带来的变化：
传统云原生架构下，基于DevOps、微服务和容器云开发应用仍然会选择一个开发框架，数据层+逻辑层+上层展现层，例如三层架构、五层架构。

Serverless无服务器化架构，开发框架、开发环境、多层架构会全部抛弃，任何一个功能的实现核心全部变成一个个代码片段，通过各个代码片段去实现功能，通过代码组合、组装实现复杂业务流程，这是Serverless 未来期望的效果。

![](./picture/serverless架构.png)
![](./picture/serverless开发流程.png)

Serverless特点：
- 默认弹性
- 无流量时支持缩容到0  
  省钱神奇
- 免运维
  免去运维成本
- 更安全
  不能SSH登录
- 零改造
  JAR包直接可跑到函数计算FC

Serverless缺点：
- 冷启动，请求到来时才运行，对于Node.js、Java和C# 启动时间过长
- 各大云平台支持框架有限
- FaaS场景下，业务拆分成很多小小函数，如何管理维护，如何关联管理是个问题
- 排查调试是个问题，分散各地的函数
- 缺少成熟的开发工具
- 完全依赖第三方服务

##### Immutable Infrastructure
不可变基础设施，云原生强调任何一个应用部署到生产环境，形成容器示例后，这个容器实例本身不应该做任何变化。如果程序、配置修改，要基于容器镜像重新去生成一个容器实例，同时销毁旧的容器实例。

##### 声明式API，Declarative-API
声明式API是和命令式操作相对应的概念

传统创建一个容器需要执行一个命令行，在声明式API下，创建容器去写一个yaml配置文件，在配置文件`声明`要做的事情，同时做完事情后期望达到的状态。声明式API下面，任何对生产环境、对软件的修改都不是直接操作一个命令，都是要先写声明、配置，声明文件(yaml文件)是可以纳入配置管理集中管控的，方便生产环境出现问题时候能快速去追溯，方便回退、回滚操作。

![](./picture/声明式vs命令式.png)

参考 云原生架构核心技术
https://cloud.tencent.com/developer/article/2218448?areaSource=106005.17


#### 4 微服务架构选型
主流微服务架构：
- Dubbo （阿里巴巴）
- Spring Cloud （Netflix）
- Kubernetes （Google）

![](./picture/微服务架构选型_基础关注点.png)

![](./picture/微服务架构选型_运维架构.png)

![](./picture/微服务架构选型_产品优缺点.png)

总结：横向对比，Dubbo、Spring Cloud对比Kubernetes有很多缺点，Google的Kubernetes 才是具备完整一站式的微服务解决方案的技术方案。

![](./picture/k8s解决的问题.png)

##### 微服务和网关
网关鉴权，网关路由，网关层面负载均衡
![](./picture/微服务选型_网关工作流程.png)

![](./picture/微服务选型_网关.png)

##### 微服务的运维监控
- 集成测试
- 日志管理
- 监控预警 业务指标监控、应用指标监控、CPU、mem、磁盘IO等
- 调用链监控 呈现分布式系统的调用关系、调用性能，找到性能瓶颈，快速定位问题
- 高可用考量

###### 基于EFK的日志采集方案
Kubernetes 中推荐使用EFK （Elasticsearch + Fluentd + Kibana）采集日志

![](./picture/EFK.png)

1 Fluentd 会将采集到的日志，发送到ES，中间可以增加kafka缓存
2 ES通过Log Parser初步解析，过滤垃圾日志
3 通过Kibana 查询ES显示日志

###### 分布式系统的服务监控方案
主流微服务监控体系：Kubernetes + Prometheus

![](./picture/微服务监控.png)

1 通过Prometheus 发现Kubernetes服务
2 通过Alert Manager监控和报警
3 通过Grafana展现和监控服务的运行指标

###### 基于Skywalking 分布式链路跟踪监控
主流的分布式链路跟踪解决方案, 无侵入分布式链路跟踪框架

![](./picture/Skywalking原理.png)

参考 云原生和微服务架构
https://www.cnblogs.com/xiao2shiqi/p/15623540.html

#### 5 微服务架构设计
构建微服务的重要原则
- 服务应该是独立，且可独立部署
- 应该从配置中心读取配置
- 对客户端是透明
- 传达健康信息

构建微服务，架构师需做到以下要求：
- 分解业务问题
  描述业务问题，寻找数据内聚
- 建立服务粒度
  大服务重构到更小服务，关注服务如何交互
- 定义服务接口
  拥抱REST理念，使用URL传达意图，使用Http码传达结果

糟糕的微服务特征？
- 过于粗粒度
  服务承担过多职责，服务跨大量表管理数据，测试用例太多
- 过于细粒度
  服务彼此依赖严重，服务内部没有逻辑

什么时机不宜使用微服务？
- 不愿投入（高度成熟的运维、伸缩）
- 管理、监控服务器需要成本
- 小型应用
- 数据事务（分布式系统处理事务困难）